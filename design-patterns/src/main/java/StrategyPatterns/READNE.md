#策略模式
## 场景描述
A公司要做一套模拟鸭子的游戏，游戏中会出现各种鸭子，一边游泳戏水，一边呱呱叫，还有一些会飞。

###方案一
设计一个超类Duck，包含方法quack()、swim()、fly() 分别模拟鸭子的叫、游泳、飞行等行为，再包含一个抽象类 display() ，
用于展示各个鸭子不同的外观，让每个鸭子子类继承父类时实现display()；
###弊端
这样做虽然每个鸭子子类继承父类时就同时拥有了父类的方法，可以达到代码复用的目的，但是这样会使某些并不适合该行为的子类也具有该行为。如果某些子类鸭子，如“橡皮鸭”，它不具备某些功能（如飞行），它就不应该拥有这个飞行的功能。当然，你可以在子类中通过 @Override 覆盖这个方法。但是当各个不同的子类都需要通过覆盖修改不同的方法时，就会非常繁琐，而且容易出现纰漏，且这些新覆盖的方法不能被复用。如“橡皮鸭”只会叫不会飞，“木头鸭”不会叫也不会飞。
以后每当有新的鸭子子类出现，你都要去检查并可能需要覆盖这些方法，想想都让人抓狂。
###方案二
在超类 Duck 中将quack()、fly() 等可变的方法用接口 QuackBehavior 接口中 Quackable()，FlyBehavior 接口中 Flyable() 来代替，
然后在每个鸭子子类中，如果具有“飞行”或“叫”这个功能就实现“飞行“或”叫“这个接口
###弊端
代码无法复用，如果有100个子类，都具有飞行的行为，你就需要重复100次代码。
##设计模式
###设计原则一：找出程序中可能需要变化的地方和不需要变化的地方，将他们独立开来。让系统中的某部分改变不会影响其他部分
由于fly()和quack()会随着鸭子的不同而改变，所以把这两个行为从Duck类中分开，建一组新类来代表各个行为
###设计原则二：针对接口编程，而不是针对实现
利用多态，针对超类型编程，执行时根据实际对象执行到真正的行为，不会被绑死在超类型的行为上。
###设计原则三：多用组合，少用继承
飞行和叫，这两种不同的行为，我们分别为其建立两组不同的行为类，然后在Duck类中通过接口实例变量结合起来，这就是组合。
使得系统具有很大的弹性，还可以在运行时动态的改变行为。